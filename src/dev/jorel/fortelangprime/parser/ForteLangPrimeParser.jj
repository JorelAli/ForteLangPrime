options {
	STATIC = false;
}

PARSER_BEGIN(ForteLangPrimeParser)

package dev.jorel.fortelangprime.parser;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

import dev.jorel.fortelangprime.ast.FLPFunction;
import dev.jorel.fortelangprime.ast.FLPLibrary;
import dev.jorel.fortelangprime.ast.expressions.Expr;
import dev.jorel.fortelangprime.ast.expressions.ExprBool;
import dev.jorel.fortelangprime.ast.expressions.ExprIntLit;
import dev.jorel.fortelangprime.ast.types.Type;

public class ForteLangPrimeParser {
	
	public static FLPLibrary parse(String input) throws ParseException {
		InputStream inputStream = new ByteArrayInputStream(input.getBytes(Charset.forName("UTF-8")));
		return new ForteLangPrimeParser(inputStream).input();
	}
	
}

PARSER_END(ForteLangPrimeParser)

//Symbols
TOKEN : { < OPENBRACKET : "(" > }
TOKEN : { < CLOSEBRACKET : ")" > }
TOKEN : { < OPENCBRACE : "{" > }
TOKEN : { < CLOSECBRACE : "}" > }
TOKEN : { < OPENSBRACKET : "[" > }
TOKEN : { < CLOSESBRACKET : "]" > }
TOKEN : { < COLON : ":" > }
TOKEN : { < SEMICOLON : ";" > }
TOKEN : { < ARROW : "->" > }
TOKEN : { < COMMA : "," > }
TOKEN : { < FAT_ARROW : "=>" > }
TOKEN : { < DOUBLE_ARROW : "->>" > }
TOKEN : { < PLAY_BUTTON : "|>" > }
TOKEN : { < AT : "@" > }
TOKEN : { < GUARD : "?:" > }
TOKEN : { < PIPE : "|" > }
TOKEN : { < EQUALS : "=" > }
TOKEN : { < LCHEVRON : "<" > }
TOKEN : { < RCHEVRON : ">" > }


//Operators
TOKEN : { < CONCAT : "++" > }
TOKEN : { < PLUS : "+" >}
TOKEN : { < ROUGHLY_EQUALS : "~=" > }

//Types
/*
Java's data types:
- byte, short, int, long, float, double
- char, boolean
*/
TOKEN : { < INT : "Int" > }
TOKEN : { < BOOL : "Bool" > }
TOKEN : { < STRING : "String" > } //Strings and chars are the same thing, char[]
//TOKEN : { < LIST : "List" > } //We'll use the [] notation to denote a List
//TOKEN : { < SET : "Set" >} //We'll use the {} notation to denote a Set

//Keywords
TOKEN : { < TRUE : "true" > }
TOKEN : { < FALSE : "false" > }
TOKEN : { < IF : "if" > }
TOKEN : { < THEN : "then" > }
TOKEN : { < ELSE : "else" > }

//File declaractions
TOKEN : { < LIBRARY : "Library" > }
//TOKEN : { < SCRIPT : "Script" > }
//TOKEN : { < FILE_TYPE : < LIBRARY > | < SCRIPT > >  }
//TOKEN : { < IMPORT : "import" > }
TOKEN : { < EXPORT : "export" > }
TOKEN : { < AS : "as" > }


//Other
TOKEN : { < PRAGMA : (["A"-"Z"])+ > }
TOKEN : { < VAR_NAME : ["A"-"Z", "a"-"z", "_"] (["A"-"Z", "a"-"z", "0"-"9", "_"])* > }
TOKEN : { < INT_LITERAL : (["0"-"9"])+ > }
TOKEN : { < NUMBER : (["0"-"9"])+ (["."])? (["0"-"9"])* > }
//TOKEN : { < PRAGMA_NUMBER : (["0"-"9", ","])+ (["."])? (["0"-"9"])* > }

//Whitespace
SKIP : { "\n" | "\r" | " " | "\t" }
SKIP : { < "#" (~["\r", "\n"])* > }

/** Main endpoint */
FLPLibrary input() : { FLPLibrary lib; } {
	//expr = expr()
	lib = program()
	<EOF>
	{ return lib; }
	//{ return expr; }
}

FLPLibrary program() : { Token name; List<String> exports; List<FLPFunction> functions; } {
  	< LIBRARY >
	name = < VAR_NAME >
	
	< OPENCBRACE >
	exports = exports()
	< CLOSECBRACE >
	
	functions = functions()
	{ return new FLPLibrary(name.image, exports, functions); }
}

List<String> exports() : { List<String> exports = new ArrayList<String>(); Token t; } {
	(
	  	< EXPORT >
	  	t = < VAR_NAME >
	  	< SEMICOLON >
	  	{ exports.add(t.image); }
	)*
	{ return exports; }
}

void epsilon() : { } {
	{
	  { }
	}
}

List<FLPFunction> functions() : { List<FLPFunction> functions = new ArrayList<FLPFunction>(); FLPFunction f; } {
  	< OPENCBRACE >
  	( 	  
		f = functionDeclaration()
		{ functions.add(f); }
	)*
	< CLOSECBRACE >
	{ return functions; }
} 

FLPFunction functionDeclaration() : { Token name; Expr expr; } {
	name = < VAR_NAME > //TODO: functionName
	types()
	< EQUALS >
	expr = expression()
	< SEMICOLON >
	{ return new FLPFunction(name.image, new Type[0], null, expr); }
}


//void pragmas() : { } {
//	(
//	 	pragma() pragmas()
//	) | epsilon()
//}
//
//void pragma() : { Token pragma; } {
//	< AT >
//	pragma = < PRAGMA >
//
//	{
//	  pragmas.add(Pragma.getPragma(pragma.image));
//	  System.out.println(pragmas);
//	}
//}

ExprIntLit integer() : { Token t; } {
  	t = < INT_LITERAL >
  	{ return new ExprIntLit(Integer.parseInt(t.image)); }	
}

Expr expression() : { Expr expr; } {
//	variable()
//	| guards()
//	| list()
	expr = integer() { return expr; }
	| expr = bool() { return expr; }
//	| set()
//	| LOOKAHEAD(2) < OPENBRACKET > expression() < CLOSEBRACKET >
//	| lambda()
//	| ifExpr()
}

//void ifExpr() : { } {
//	< IF >
//	expression()
//	< THEN >
//	expression()
//	< ELSE >
//	expression()
//}

//void set() : { } {
//	< OPENCBRACE >
//	setDeclarations()
//	< CLOSECBRACE >
//}
//
//void setDeclarations() : { } {
//	setElements() | epsilon()
//}
//
//void setElements() : { } {
//	functionDeclaration() < SEMICOLON > (setElements())?
//}
//
//void variable() : { } {
//	< VAR_NAME >

//	LOOKAHEAD ( { pragmas.contains(Pragma.IF) } )
//	( LOOKAHEAD(2)
//		{
//			if(!getToken(0).image.equals("if")) {
//				throw new Exception("Expected if");
//			}
//		}
//		expression()
//		< VAR_NAME >
//		{
//			if(!getToken(0).image.equals("then")) {
//				throw new Exception("Expected then");
//			}
//		}
//		expression()
//		< VAR_NAME >
//		{
//			if(!getToken(0).image.equals("else")) {
//				throw new Exception("Expected else");
//			}
//		}
//		expression()
//	)?
//}

ExprBool bool() : { boolean b;} {
	( < TRUE > { b = true; }
	| < FALSE > { b = false;}
	)
	{ return new ExprBool(b); }
}

//void lambda() : { } {
//	< OPENBRACKET > functionDeclaration() < CLOSEBRACKET >
//}

void types() : { } {
	identifier()
	< LCHEVRON >
	type()
	< RCHEVRON >
	(		< ARROW >
		types()
	)?
}

void type() : { } {
	"Int"
	| "String"
	| "Bool"
	| < OPENSBRACKET > type() < CLOSESBRACKET >
//	| < OPENCBRACE > setTypes() < CLOSECBRACE >
}

//void setTypes() : { } {
//	"..." | otherSetTypes()
//}
//
//void otherSetTypes() : { } {
//	< VAR_NAME > //TODO: namedIdentifier
//	< LCHEVRON >
//	type()
//	< RCHEVRON >
//	(
//	  < COMMA >
//	  (
//	    "..." | otherSetTypes()
//	  )
//	)?
//}
//
void identifier() : { } {
	< VAR_NAME > | epsilon()
}
//
//
//
//void list() : { } {
//	< OPENSBRACKET >
//	listContents()
//	< CLOSESBRACKET >
//}
//
//void listContents() : { } {
//	listElements() | epsilon()
//}
//
//void listElements() : { } {
//	expression() (< COMMA > listElements())?
//}
//
//void guards() : { } {
//	< GUARD >
//	innerGuards()
//}
//
//void innerGuards() : { } {
//   LOOKAHEAD(2)
//	(
//	  guard() innerGuards()
//	) | (
//		< PIPE >
//		< FAT_ARROW >
//		expression()
//	)//epsilon()
//}
//
//void guard() : { } {
//	< PIPE > expression() < FAT_ARROW > expression()
//}
