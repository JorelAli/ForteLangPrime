options {
	STATIC = false;
	JAVA_TEMPLATE_TYPE = "modern";
}

PARSER_BEGIN(ForteLangPrimeParser)

package dev.jorel.fortelangprime.parser;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

import dev.jorel.fortelangprime.ast.*;
import dev.jorel.fortelangprime.ast.expressions.*;
import dev.jorel.fortelangprime.ast.types.*;
import dev.jorel.fortelangprime.parser.util.*;
import dev.jorel.fortelangprime.compiler.*;

public class ForteLangPrimeParser {

  	private static UniversalContext universalContext;
  	private static String currentFunctionName;
	
	public static FLPLibrary parse(String input) throws ParseException, IOException {
		universalContext = new UniversalContext();
		InputStream inputStream = new ByteArrayInputStream(input.getBytes(Charset.forName("UTF-8")));
		return new ForteLangPrimeParser(new StreamProvider(inputStream)).input();
	}

	public static FLPLibrary parse(File input) throws ParseException, FileNotFoundException, IOException {
		universalContext = new UniversalContext();
	  	return new ForteLangPrimeParser(new StreamProvider(new FileInputStream(input))).input();
	}

	public static UniversalContext getUniversalContext() {
		return ForteLangPrimeParser.universalContext;
	}
	
}

PARSER_END(ForteLangPrimeParser)

TOKEN_MGR_DECLS : {
    static int commentNesting = 0;
}

// Symbols
TOKEN : {
		< OPENBRACKET : "(" >
	|	< CLOSEBRACKET : ")" >
	|	< OPENCBRACE : "{" > 
	|	< CLOSECBRACE : "}" > 
	|	< OPENSBRACKET : "[" > 
	|	< CLOSESBRACKET : "]" > 
	|	< COLON : ":" > 
	|	< SEMICOLON : ";" > 
	|	< ARROW : "->" > 
	|	< COMMA : "," > 
	|	< FAT_ARROW : "=>" > 
	|	< DOUBLE_ARROW : "->>" > 
	|	< PLAY_BUTTON : "|>" > 
	|	< GUARD : "?:" > 
	|	< PIPE : "|" > 
	|	< EQUALS : "=" > 
	|	< LCHEVRON : "<" > 
	|	< RCHEVRON : ">" >
}

// Generators
TOKEN : {
		< PRINTABLE : "@Printable" >
	|	< EQUATABLE : "@Equatable" >
}

// Operators
TOKEN : { 
		< CONCAT : "++" > 
	|	< PLUS : "+" >
	|	< ROUGHLY_EQUALS : "~=" >
	|	< EQUALS_EQUALS : "==" >
}

// Types (and type-related keywords)
TOKEN : { 
		< TYPE_INT : "Int" > 
	|	< TYPE_BOOL : "Bool" > 
	|	< TYPE_STRING : "String" >
	|	< TYPE : "type" >
}

// Keywords (used in programming)
TOKEN : { 
		< IF : "if" > 
	|	< THEN : "then" > 
	|	< ELSE : "else" > 
}

// Constants
TOKEN : {
		< TRUE : "true" > 
	| 	< FALSE : "false" > 
	| 	< PANIC : "panic" >
}

// File Meta Keywords
TOKEN : {
		< LIBRARY : "Library" >
	|	< SCRIPT : "Script" >
	|	< EXPORT : "export" >
	|	< IMPORT : "import" >  
	|	< AS : "as" >
}

// Other
TOKEN : { 
		< VAR_NAME : ["A"-"Z", "a"-"z", "_"] (["A"-"Z", "a"-"z", "0"-"9", "_"])* > 
	|	< INT_LITERAL : (["0"-"9"])+ > 
	|	< NUMBER : (["0"-"9"])+ (["."])? (["0"-"9"])* > 
	|	< STRING : "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >
}

// Whitespace
SKIP : {
  		"\n"
  	| 	"\r"
  	| 	" "
  	| 	"\t"
  	| 	"\f"
}

// Comments
SKIP : {
  		// Single-line comments
		< "##" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")>
	| 	"#[" { commentNesting++; } : InsideMLC
}

<InsideMLC> SKIP : {
		"#[" { commentNesting++; }
    |	"]#" {
				commentNesting--;
				if (commentNesting == 0) {
					SwitchTo(DEFAULT);
				}
			 }
}

<InsideMLC> MORE : {
	<~[]>
}

/** Main endpoint */
FLPLibrary input() : { FLPLibrary lib; } {
	lib = program()
	<EOF>
	{ return lib; }
}

FLPLibrary program() : {
	Token name; List<String> exports;
	List<RecordTypeDeclaration> typeDeclarations;
	List<FLPFunction> functions;
} {
  	< LIBRARY >
	name = < VAR_NAME >
	
	< OPENCBRACE >
	exports = exports()
	< CLOSECBRACE >

	< OPENCBRACE >

	//TODO: Make it so you can put type declarations anywhere, not just at the start of the file
	typeDeclarations = typeDeclarations()
	functions = functions()

	< CLOSECBRACE >
	{ return new FLPLibrary(name.image, exports, functions, typeDeclarations); }
}

List<String> exports() : { List<String> exports = new ArrayList<String>(); Token t; } {
	(
	  	< EXPORT >
	  	t = < VAR_NAME >
	  	< SEMICOLON >
	  	{ exports.add(t.image); }
	)*
	{ return exports; }
}

void epsilon() : { } {
	{
	  { }
	}
}

List<RecordTypeDeclaration> typeDeclarations() : {
	List<RecordTypeDeclaration> list = new ArrayList<RecordTypeDeclaration>();
	Token name;
	TypeRecord type;
	boolean printable = false;
} {
  	(
  	  	(			< PRINTABLE >
			{ printable = true; }
  	  	)?
		< TYPE >
		name = < VAR_NAME >
		< EQUALS >
		type = recordType(name.image)
		{
			universalContext.addRecordType(name.image, type); 
			list.add(new RecordTypeDeclaration(name.image, type, printable));
		}
	)*
	{ return list; }
}

List<FLPFunction> functions() : {
  	List<FLPFunction> functions = new ArrayList<FLPFunction>();
  	FLPFunction f;
} {
  	( 	  
		f = functionDeclaration()
		{ functions.add(f); }
	)*
	{ return functions; }
} 

FLPFunction functionDeclaration() : {
	List<TypeNamedGeneric> genericTypeDeclaration = new ArrayList<TypeNamedGeneric>();
  	Token name;
  	Expr expr;
  	List<Pair<String, Type>> functionTypes;
  	TypeFunction tf;
} {
  	(genericTypeDeclaration = genericTypeDeclaration())?
	name = < VAR_NAME >
	{ ForteLangPrimeParser.currentFunctionName = name.image; }
	functionTypes = functionTypes()
	{
	  	tf = Converter.functionTypesToTypeFunction(functionTypes);
	  	universalContext.addFunction(name.image, tf);
	}
	< EQUALS >
	expr = expression()
	< SEMICOLON >
	{ return new FLPFunction(name.image, tf, genericTypeDeclaration, expr); }
}

List<TypeNamedGeneric> genericTypeDeclaration() : {
	Token t;
	List<TypeNamedGeneric> genericNames = new ArrayList<TypeNamedGeneric>();
} {
	< LCHEVRON >
	t = < VAR_NAME >
	{ genericNames.add(new TypeNamedGeneric(t.image)); }
	(		< COMMA >
		t = < VAR_NAME >
		{ genericNames.add(new TypeNamedGeneric(t.image)); }
	)*
	< RCHEVRON >
	{ return genericNames; }
}

Expr expression() : {
  	Expr expr;
  	Expr secondaryExpr;
  	Token op;
} {
	( expr = integer()
	| expr = bool()
	| expr = string()
	| expr = panic()
	| expr = variable()
	| expr = ifStatement()
	| expr = recordExpr()
	)
	( LOOKAHEAD(2)		op = < EQUALS_EQUALS >
		secondaryExpr = expression()
		{ expr = new ExprBinaryOp(op.beginLine, expr, secondaryExpr, Operation.from(op.kind));}
	)?
	{ return expr; }
}

ExprRecordConstruction recordExpr() : {  
	List<Pair<String, Expr>> values = new ArrayList<Pair<String, Expr>>();
	Token startingToken;
	Expr base = null;
	Token t;
	Expr expr;
} {
  	startingToken = < OPENCBRACE >
  	( LOOKAHEAD(2)
  	  	base = variable()
  	 	< PIPE >  	  	)?
	(
		t = < VAR_NAME >
		< EQUALS >
		expr = expression()
		< SEMICOLON >
		{ values.add(Pair.of(t.image, expr)); }
	)*
	< CLOSECBRACE >
	{ return new ExprRecordConstruction(startingToken.beginLine, base, values); }
}

ExprVariable variable() : {
  	Token t;
  	List<Expr> expressions = new ArrayList<Expr>();
  	Expr e;
} {
  	t = < VAR_NAME >
  	( LOOKAHEAD(2)
		e = expression()
		{ expressions.add(e); }  	)*
  	{ return new ExprVariable(t.beginLine, t.image, ForteLangPrimeParser.currentFunctionName, expressions); }
}

ExprIfStatement ifStatement() : {
	Token t;
  	Expr a;
  	Expr b;
  	Expr c;
} {
  	t = < IF >
  	a = expression()
  	< THEN >
  	b = expression()
  	< ELSE >
  	c = expression()
  	{ return new ExprIfStatement(t.beginLine, a, b, c); }
}

ExprIntLit integer() : {
  	Token t;
} {
  	t = < INT_LITERAL >
  	{ return new ExprIntLit(t.beginLine, Integer.parseInt(t.image)); }	
}

ExprBoolLit bool() : {
	Token t;
	boolean value;
} {
	( t = < TRUE > { value = true; }
	| t = < FALSE > { value = false; }
	) 
	{ return new ExprBoolLit(t.beginLine, value); }
}

ExprStringLit string() : {
  	Token t;
} {
  	t = < STRING >
	{ return new ExprStringLit(t.beginLine, t.image.substring(1, t.image.length() - 1)); }
}

ExprPanic panic() : {
	Token t;
} {
	t = < PANIC >
	{ return new ExprPanic(t.beginLine); }
} 

List<Pair<String, Type>> functionTypes() : {
  	List<Pair<String, Type>> types = new ArrayList<Pair<String, Type>>();
  	List<Pair<String, Type>> otherTypes = new ArrayList<Pair<String, Type>>();
	Type t;
	Token varName;
} {
  	{ varName = null; }
	(
	  	varName = < VAR_NAME >
	)?
	< LCHEVRON >
	t = type()
	{
	  	if(varName == null) {
			types.add(Pair.of(null, t));
	  	} else {
			types.add(Pair.of(varName.image, t));
	  	}
	}
	< RCHEVRON >
	(
		< ARROW >
		otherTypes = functionTypes()
		{ types.addAll(otherTypes); }
	)?
	{ return types; }
}

Type type() : {
	Token t;
	Type type;
} {
	( < TYPE_INT > { type = new TypeInt(); }
	| < TYPE_STRING > { type = new TypeString(); }
	| < TYPE_BOOL > { type = new TypeBool(); }
	//TODO: Add generic to this constructor
	| t = < VAR_NAME > (< LCHEVRON > type() < RCHEVRON >)? { type = new TypeNamedGeneric(t.image); }
	//TODO: Implement record types
//	| type = recordType("")
	)
	{ return type; }
}

TypeRecord recordType(String name) : {
	List<Pair<String, Type>> types = new ArrayList<Pair<String, Type>>();
	Token t;
	Type type;
} {
  	< OPENCBRACE >
	(
		t = < VAR_NAME >
		< LCHEVRON >
		type = type()
		< RCHEVRON >
		< SEMICOLON >
		{ types.add(Pair.of(t.image, type)); }
	)*
	< CLOSECBRACE >
	{ return new TypeRecord(name, types); }
}
