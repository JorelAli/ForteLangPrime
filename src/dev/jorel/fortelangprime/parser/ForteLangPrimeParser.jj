options {
	STATIC = false;
}

PARSER_BEGIN(ForteLangPrimeParser)

package dev.jorel.fortelangprime.parser;

import java.io.ByteArrayInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.File;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.List;

import dev.jorel.fortelangprime.ast.*;
import dev.jorel.fortelangprime.ast.expressions.*;
import dev.jorel.fortelangprime.ast.types.*;
import dev.jorel.fortelangprime.parser.util.*;

public class ForteLangPrimeParser {

  	private static TypingContext typingContext;
  	private static String currentFunctionName;
	
	public static FLPLibrary parse(String input) throws ParseException {
		typingContext = new TypingContext();
		InputStream inputStream = new ByteArrayInputStream(input.getBytes(Charset.forName("UTF-8")));
		return new ForteLangPrimeParser(inputStream).input();
	}

	public static FLPLibrary parse(File input) throws ParseException, FileNotFoundException {
		typingContext = new TypingContext();
	  	return new ForteLangPrimeParser(new FileInputStream(input)).input();
	}

	public static TypingContext getTypingContext() {
		return ForteLangPrimeParser.typingContext;
	}
	
}

PARSER_END(ForteLangPrimeParser)

TOKEN_MGR_DECLS : {
    static int commentNesting = 0;
}

// Symbols
TOKEN : {
		< OPENBRACKET : "(" >
	|	< CLOSEBRACKET : ")" >
	|	< OPENCBRACE : "{" > 
	|	< CLOSECBRACE : "}" > 
	|	< OPENSBRACKET : "[" > 
	|	< CLOSESBRACKET : "]" > 
	|	< COLON : ":" > 
	|	< SEMICOLON : ";" > 
	|	< ARROW : "->" > 
	|	< COMMA : "," > 
	|	< FAT_ARROW : "=>" > 
	|	< DOUBLE_ARROW : "->>" > 
	|	< PLAY_BUTTON : "|>" > 
	|	< AT : "@" > 
	|	< GUARD : "?:" > 
	|	< PIPE : "|" > 
	|	< EQUALS : "=" > 
	|	< LCHEVRON : "<" > 
	|	< RCHEVRON : ">" >
}

// Operators
TOKEN : { 
		< CONCAT : "++" > 
	|	< PLUS : "+" >
	|	< ROUGHLY_EQUALS : "~=" > 
}

// Types (and type-related keywords)
TOKEN : { 
		< TYPE_INT : "Int" > 
	|	< TYPE_BOOL : "Bool" > 
	|	< TYPE_STRING : "String" >
	|	< TYPE : "type" >
}

// Keywords (used in programming)
TOKEN : { 
		< IF : "if" > 
	|	< THEN : "then" > 
	|	< ELSE : "else" > 
}

// Constants
TOKEN : {
		< TRUE : "true" > 
	| 	< FALSE : "false" > 
	| 	< PANIC : "panic" >
}

// File Meta Keywords
TOKEN : {
		< LIBRARY : "Library" >
	|	< SCRIPT : "Script" >
	|	< EXPORT : "export" >
	|	< IMPORT : "import" >  
	|	< AS : "as" >
}

// Other
TOKEN : { 
		< VAR_NAME : ["A"-"Z", "a"-"z", "_"] (["A"-"Z", "a"-"z", "0"-"9", "_"])* > 
	|	< INT_LITERAL : (["0"-"9"])+ > 
	|	< NUMBER : (["0"-"9"])+ (["."])? (["0"-"9"])* > 
	|	< STRING : "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >
}

// Whitespace
SKIP : {
  		"\n"
  	| 	"\r"
  	| 	" "
  	| 	"\t"
  	| 	"\f"
}

// Comments
SKIP : {
  		// Single-line comments
		< "##" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")>
	| 	"#[" { commentNesting++; } : InsideMLC
}

<InsideMLC> SKIP : {
		"#[" { commentNesting++; }
    |	"]#" {
				commentNesting--;
				if (commentNesting == 0) {
					SwitchTo(DEFAULT);
				}
			 }
}

<InsideMLC> MORE : {
	<~[]>
}

/** Main endpoint */
FLPLibrary input() : { FLPLibrary lib; } {
	lib = program()
	<EOF>
	{ return lib; }
}

FLPLibrary program() : {
	Token name; List<String> exports;
	List<TypeDeclaration> typeDeclarations;
	List<FLPFunction> functions;
} {
  	< LIBRARY >
	name = < VAR_NAME >
	
	< OPENCBRACE >
	exports = exports()
	< CLOSECBRACE >

	< OPENCBRACE >

	//TODO: Implement type declarations
	//TODO: Make it so you can put type declarations anywhere, not just at the start of the file
	typeDeclarations = typeDeclarations()
	functions = functions()

	< CLOSECBRACE >
	{ return new FLPLibrary(name.image, exports, functions); }
}

List<String> exports() : { List<String> exports = new ArrayList<String>(); Token t; } {
	(
	  	< EXPORT >
	  	t = < VAR_NAME >
	  	< SEMICOLON >
	  	{ exports.add(t.image); }
	)*
	{ return exports; }
}

void epsilon() : { } {
	{
	  { }
	}
}

List<TypeDeclaration> typeDeclarations() : {
	List<TypeDeclaration> list = new ArrayList<TypeDeclaration>();
} {
	< TYPE >
	< VAR_NAME >
	< EQUALS >
	recordType()
	{ return list; }
}

List<FLPFunction> functions() : {
  	List<FLPFunction> functions = new ArrayList<FLPFunction>();
  	FLPFunction f;
} {
  	( 	  
		f = functionDeclaration()
		{ functions.add(f); }
	)*
	{ return functions; }
} 

FLPFunction functionDeclaration() : {
	List<TypeNamedGeneric> genericTypeDeclaration = new ArrayList<TypeNamedGeneric>();
  	Token name;
  	Expr expr;
  	List<Pair<String, Type>> functionTypes;
  	TypeFunction tf;
} {
  	(genericTypeDeclaration = genericTypeDeclaration())?
	name = < VAR_NAME >
	{ ForteLangPrimeParser.currentFunctionName = name.image; }
	functionTypes = functionTypes()
	{
	  	tf = Converter.functionTypesToTypeFunction(functionTypes);
	  	typingContext.addFunction(name.image, tf);
	}
	< EQUALS >
	expr = expression()
	< SEMICOLON >
	{ return new FLPFunction(name.image, tf, genericTypeDeclaration, expr); }
}

List<TypeNamedGeneric> genericTypeDeclaration() : {
	Token t;
	List<TypeNamedGeneric> genericNames = new ArrayList<TypeNamedGeneric>();
} {
	< LCHEVRON >
	t = < VAR_NAME >
	{ genericNames.add(new TypeNamedGeneric(t.image)); }
	(		< COMMA >
		t = < VAR_NAME >
		{ genericNames.add(new TypeNamedGeneric(t.image)); }
	)*
	< RCHEVRON >
	{ return genericNames; }
}

Expr expression() : {
  	Expr expr;
} {
	expr = integer() { return expr; }
	| expr = bool() { return expr; }
	| expr = string() { return expr; }
	| expr = panic() { return expr; }
	| expr = variable() { return expr; }
	| expr = ifStatement() { return expr; }
}

ExprVariable variable() : {
  	Token t;
} {
  	t = < VAR_NAME >
  	{ return new ExprVariable(t.beginLine, t.image, ForteLangPrimeParser.currentFunctionName); }
}

ExprIfStatement ifStatement() : {
	Token t;
  	Expr a;
  	Expr b;
  	Expr c;
} {
  	t = < IF >
  	a = expression()
  	< THEN >
  	b = expression()
  	< ELSE >
  	c = expression()
  	{ return new ExprIfStatement(t.beginLine, a, b, c); }
}

ExprIntLit integer() : {
  	Token t;
} {
  	t = < INT_LITERAL >
  	{ return new ExprIntLit(t.beginLine, Integer.parseInt(t.image)); }	
}

ExprBoolLit bool() : {
  	Token t;
} {
	( t = < TRUE >  { return new ExprBoolLit(t.beginLine, true); }
	| t = < FALSE > { return new ExprBoolLit(t.beginLine, false); }
	)
}

ExprStringLit string() : {
  	Token t;
} {
  	t = < STRING >
	{ return new ExprStringLit(t.beginLine, t.image.substring(1, t.image.length() - 1)); }
}

ExprPanic panic() : {
	Token t;
} {
	t = < PANIC >
	{ return new ExprPanic(t.beginLine); }
} 

List<Pair<String, Type>> functionTypes() : {
  	List<Pair<String, Type>> types = new ArrayList<Pair<String, Type>>();
  	List<Pair<String, Type>> otherTypes = new ArrayList<Pair<String, Type>>();
	Type t;
	Token varName;
} {
  	{ varName = null; }
	(
	  	varName = < VAR_NAME >
	)?
	< LCHEVRON >
	t = type()
	{
	  	if(varName == null) {
			types.add(Pair.of(null, t));
	  	} else {
			types.add(Pair.of(varName.image, t));
	  	}
	}
	< RCHEVRON >
	(
		< ARROW >
		otherTypes = functionTypes()
		{ types.addAll(otherTypes); }
	)?
	{ return types; }
}

Type type() : {
	Token t;
	Type type;
} {
	< TYPE_INT > { return new TypeInt(); }
	| < TYPE_STRING > { return new TypeString(); }
	| < TYPE_BOOL > { return new TypeBool(); }
	//TODO: Add generic to this constructor
	| t = < VAR_NAME > (< LCHEVRON > type() < RCHEVRON >)? { return new TypeNamedGeneric(t.image); }
	//TODO: Implement record types
	| type = recordType() { return type; }
}

Type recordType() : {

} {
  	< OPENCBRACE >
	(
		< VAR_NAME >
		< LCHEVRON >
		type()
		< RCHEVRON >
		< SEMICOLON >
	)*
	< CLOSECBRACE >
	{ return null; }
}
