Library Sample {
	
	export *;

} {


	## Record type declaration
	@Equatable
	@Printable
	type Color = {
		red<Int>;
		green<Int>;
		blue<Int>;
	}

	## Basic functions (returning simple parameters)
	justTwo <Int> = 2;
	aString <String> = "hello";
	someBool <Bool> = true;
	panicTest <Bool> = panic;

	## Functions with parameters
	paramFunction <Int> -> <Int> = 2;
	identity a<Int> -> <Int> = a;
	identity1 a3<Bool> -> <Bool> = a3;
	identity2 a2<String> -> <String> = a2;
	multiParam a1<Int> -> a2<String> -> <String> = a2;

	## Generics
	<T> id a<T> -> <T> = a;

	## Useful functions
	not input<Bool> -> <Bool> = if input then false else true;

	## If statements
	alwaysFalse <Bool> = if true then if true then false else true else true;

	## Fully defined records
	red <Color> = { red = 255; green = 0; blue = 0; };
	green <Color> = { green = 255; red = 0; blue = 0; };

	greenInt <Int> = { red = 255; green = 0; blue = 0; }.green;

	## Record updating using the red function as a base
	yellow <Color> = { red | green = 255; };

	someOtherBool <Bool> = someBool;
	someOtherOtherBool <Bool> = identity1 someBool;

	and a<Bool> -> b<Bool> -> <Bool> = if not a then false else if not b then false else true;

	eqInt a<Int> -> b<Int> 		 -> <Bool> = a == b;
	eqStr a<String> -> b<String> -> <Bool> = a == b;
	eqBool a<Bool> -> b<Bool> 	 -> <Bool> = a == b;
	eqColor a<Color> -> b<Color> -> <Bool> = a == b;

	testCustomOperator <Bool> = true >>= false;

	infix 2 bind (>>=) <Bool> -> <Bool> -> <Bool> = true;

	mul a<Int> -> b<Int> -> <Int> = a * b;
	pow a<Int> -> b<Int> -> <Int> = a ^ b;
	add a<Int> -> b<Int> -> <Int> = a + b;
	sub a<Int> -> b<Int> -> <Int> = a - b;

	## Testing the order of operations
	## Don't expect (l2r): 5 - 2 => 3 * 3 => 9 + 4 => 13
	## Don't expect (r2l): 3 + 4 => 2 * 7 => 5 - 14 => -9
	## Expect 3 (5 - 6 => -1 + 4 => 3)
	ooo <Int> = 5 - 2 * 3 + 4; 

	## testConditionGt <Bool> = 2 > 3;
}
