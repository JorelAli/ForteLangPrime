#[A sample program that shows the basic stucture and new syntax for ForteLangPrime]#

{

	## Types are declared using the 
	## < and > operators. List types are 
	## declared using []. Supports higher
	## level types similar to System F
	map function<(a -> b)> -> list<[a]> -> <[b]> =

		## ForteLangPrime, similar to ForteLang doesn't
		## require special indentation.

		## Pattern matching (previously the "match" keyword
		## in ForteLang) is replaced using the unary operator
		## ?=, which is declared before the name of the variable
		## to match on
		?= list
		| [] ->> []
		| ->> [function list] ++ map (tail list) function;

	## Guards are now handled using the ?: operator
	## Guards are the only structure (in addition to matching)
	## that lets you perform conditional statements
	max i<Num> -> j<Num> -> <Num> =
		?: | i < j ->> j | ->> i;

	## Set "matching" is performed at the type level. It lets you
	## require sets with certain attributes and certain types, as well
	## as "extra", by using the ... operator
	isComplex i<{re<Num>, im<Num>, ...}> -> <Bool> = true;

	## This example shows the use of set construction, as well as accessing
	## elements from sets. The type signature <{re<Num>, im<Num>, ...}>
	## indicates that the parameter c1 has type that is a set containing 
	## named attributes re and im, which are both of type Num. In addition to that
	## c1 may also contain other members, but these are cannot be accessed
	## within this function
	addComplex c1<{re<Num>, im<Num>, ...}> -> c2<{re<Num>, im<Num>, ...}> -> <{re<Num>, im<Num>}> =
		{
			re <Num> = c1.re + c2.re;
			im <Num> = c1.im + c2.im;
		};

	## an example of the type signature for a constant
	pi <Num> = 3.14159;

	## An example of how the names for unused parameters can be straight up ommitted
	onlyFirst firstElement<a> -> <b> -> <a> = firstElement;

	## An example of how the "Maybe" type can be implemented
	## in ForteLangPrime... maybe
	just element<a> -> <{just<a>}> = { just <a> = element; };
	nothing -> <{nothing<a>}> = { nothing <a> = !!; };
	exampleMatch set<{...}> -> <Bool> =
		?= 
		| {just<a>, ...} ->> true
		| {nothing<a>, ...} -> false;

	## Function composition has a few forms. For example, we have
	## toString : Num -> String and toCharList : String -> [String]
	## If we want to convert a number to a [String], we can do
	## toString, followed by toCharList.
	toString number<Num> -> <String> = #[ Some implementation ]#;
	toCharList string<String> -> <[String]> = #[ Some other implementation ]#;
	numToCharList number<Num> -> <[String]> = toCharList (toString number);
	numToCharList number<Num> -> <[String]> = toString number |> toCharList;

	## Despite being well typed, ForteLangPrime (similar to ForteLang)
	## will not have the ability to declare type aliases or custom types.
	## This design choice is heavily inspired by the Nix expression language.
}
